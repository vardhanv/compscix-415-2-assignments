---
title: "COMPSCIX 415.2 Homework 4"
author: "Vishnu Vardhan"
date: "2/23/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('tidyverse')
library('nycflights13')
library('dplyr')
library(ggthemes)
```


### Q 5.6.7.2
Come up with another approach that will give you the same output as not_cancelled %>% count(dest) and not_cancelled %>% count(tailnum, wt = distance) (without using count()).

#### Answer

Lets first find out what the expected output is:

```{r}
not_cancelled <- flights %>% filter(!is.na(dep_delay),!is.na(arr_delay))

not_cancelled %>% count(dest)
not_cancelled %>% count(tailnum, wt = distance)
```


We can recreate this using group_by and summarse as follow:

```{r}
not_cancelled %>% group_by(dest) %>% summarise(n = n())
not_cancelled %>% group_by(tailnum) %>%  summarise( n = sum(distance))
```




### Q 5.6.7.4
Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay?

#### Answer

A histogram shows that most delays seem to be less than 25 minutes. As the delay incrases the number of cancelled flights increase. The effect is much more severe after the 25 minute mark.

```{r}
d <- flights %>% group_by(year,month,day) %>% 
  summarise( 
    c_mean     = mean(is.na(dep_delay) | is.na(arr_delay)), 
    delay_mean = mean(dep_delay + arr_delay, na.rm = TRUE))

ggplot(data = d) + geom_histogram(aes(delay_mean)) + labs(title = "Histogram of average Daily Delay", x = "Avg daily delay") + theme_bw()

ggplot(data = d,mapping = aes(delay_mean,c_mean)) + geom_point(alpha=0.2) + labs(y = "Propotion of cancelled flights", x = "Avg daily delay") + theme_bw()


```


### Q 5.6.7.5
Which carrier has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about flights %>% group_by(carrier, dest) %>% summarise(n()))

#### Answer

The carrier EV has the worst delays.

```{r}

worst_carrier <- flights %>% group_by(carrier) %>% summarise( delay = sum(dep_delay + arr_delay, na.rm = TRUE))


ggplot(data = worst_carrier, mapping = aes(x=carrier, y=delay)) + geom_col() + theme_bw()
```


As can be seen in the table below, the number of flights into a particular destination can be fairly large. There are 314 such carrier/dest combinations.

I believe the way to test dependence/inter-dependence is to identify if each of these groups is a normal distribution. If it is normal, then there is no relationship between that combination of airport/carrier. Once we identify combinations that are related, then we need to compare the distribution of the combination versus the two populations of airline and carrier.

i.e Lets assume we identify that DL/ATL with 10571 flights is a non-normal distribution with respect to delays. 

1. Compre the distribution of delays of all DL flights with that of DL/ATL flights. Similar distribution means Atlanta is not playing any role in delta's delays. Else, Atlanta is playing a role. 

2. Compre distribution of delays of all Atlanta flights, with that of all DL/ATL flights. Similar distribution means delta is not playing any role in delays seen at Atlanta. Else, delta is playing a role. 

Quick research indicates that we should likely use the Q-Q plot, but i don't understand this enough to plot it for this assignment.

```{r}
flights %>% group_by(carrier,dest) %>% summarise(c = n()) %>% arrange(desc(c))
```





### Q 5.6.7.6
What does the sort argument to count() do. When might you use it?

#### Answer

Lets start with a bunch of experiements with the following code:

flights %>% group_by(carrier,dest) %>% summarise(c = n()) %>% arrange(desc(c))
flights %>% group_by(carrier,dest) %>% count(sort = TRUE)
flights %>% count(sort = TRUE)
flights %>% group_by(carrier) %>% count(sort = TRUE)
flights %>% group_by(carrier,dest) %>% summarise(c = n()) %>% count(sort = TRUE)

The help states that: Count/tally observations by group

'sort = TRUE`, changes how the tibble is ordered, and is the same as using 'arrange' with a 'desc' function.



### Q 10.5.1
How can you tell if an object is a tibble? (Hint: try printing mtcars, which is a regular data frame).

#### Answer

Printing a tibble prints a summary, describing the number of rowsXcolumns, followed by the number of columns that print on the screen, and their type, the data for these columns, and an end summary that prints the remaning columns that did not fit on the screen and their respective types.

Reading the chapter reveals that a tibble is, in general, a much more restricted data frame. Reducing functionality vs a raw data.frame, but when combined with functions in the library result in much cleaner, re-usable code.



### Q 10.5.2
Compare and contrast the following operations on a data.frame and equivalent tibble. What is different? Why might the default data frame behaviours cause you frustration?

df <- data.frame(abc = 1, xyz = "a")
df$x
df[, "xyz"]
df[, c("abc", "xyz")]

#### Answer

Trying to do the same thing with tibbles needs the following code
```{r}
t <- tribble( ~abc, ~xyz, 1,"a")
```

Running these commands shows that each is a way to select columns. The essential

The key difference is the partial column match that data.frames allow. Partial column matches, though interesting, make it very difficult to predictability write code when you have large numbers of columns, from disparate sources.


### Q 10.5.3
If you have the name of a variable stored in an object, e.g. var <- "mpg", how can you extract the reference variable from a tibble?

#### Answer

You can use the '[[' operator to access the values.

Example:
```{r}
t <- tribble( ~abc, ~xyz, 1,"a")
var <- "xyz"
t[[var]]
```


### Q 10.5.6
What option controls how many additional column names are printed at the footer of a tibble?

#### Answer


### Q 12.3.3.2
Why does this code fail?

table4a %>% 
  gather(1999, 2000, key = "year", value = "cases")
> Error in combine_vars(vars, ind_list): Position must be between 0 and n

#### Answer



### Q 12.3.3.3
Why does spreading this tibble fail? How could you add a new column to fix the problem?

people <- tribble(
  ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)

#### Answer



### Q 12.3.3.4
Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?

preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)

#### Answer


### Q 12.4.3.1
What do the extra and fill arguments do in separate()? Experiment with the various options for the following two toy datasets.

tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))


#### Answer



### Q 12.4.3.2
Both unite() and separate() have a remove argument. What does it do? Why would you set it to FALSE?


#### Answer


